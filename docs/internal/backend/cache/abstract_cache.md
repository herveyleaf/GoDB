对应MYDB的common/AbstractCache.java

##

GoDB使用的缓存框架为引用计数策略，所以除了最基本的缓存功能，还要维护一个计数，然后为了应对多线程环境，还要记录哪些资源正在被获取。基于以上设计，可以定义出一个缓存的结构体

并且在获取资源的时候不使用死循环进行无限尝试取缓存，而是使用一个条件变量cond来控制资源调度

由于Golang中没有构造函数，所以一般使用创建一个叫做NewXXXXXX的函数，返回对应的结构体

##

在Get函数中，首先需要加锁，然后检查想要取的缓存是否正在被其它goroutine访问，如果正在被访问，那么就等待，直到正在访问的goroutine访问结束，再次尝试，这样就不需要一直循环，节约资源

然后检查缓存中是否有想要的资源，如果有的话就直接返回，否则我们就从数据源去获取这个资源，并将其加入到缓存中

所以接下来需要检查缓存的容量，如果容量足够的话就将该资源标记成正在获取，然后调用抽象方法GetForCache(资源不在缓存时的获取行为)进行操作，完成获取后通知其它等待的goroutine

## 

在Release函数中只需要修改缓存对应的reference的值即可，如果reference == 0，那么调用抽象方法ReleaseForCache(资源被驱逐时的写回行为)将其刷回磁盘中，然后做一些清除工作即可

## 

Close函数是用于安全的关闭缓存，将缓存中的所有资源刷回磁盘中

## 

GetForCache和ReleaseForCache这两个方法是抽象方法，但是由于Golang没有抽象方法的语法，所以在这里写panic，如果子类没有重写AbstractCache的这两个抽象方法的话就会报错