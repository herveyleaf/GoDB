Page接口定义了一些页所必需的操作，加锁解锁、释放、设置为脏页、检查是否为脏页、获取数据和页号

Page的实现主要定义了页的基本数据结构，页号、数据、是否为脏页、锁和一个页的缓存，接口函数的实现也都是简单的赋值和调用方法

对于数据页的管理，分为了第一页和其它页，数据库文件的第一页通常用作一些特殊用途，GoDB的第一页只用来做启动检查。具体原理是在每次数据库启动时，生成一串随机字节存储在第一页的100~107字节，数据库正常关闭的时候这串字节会被拷贝到第一页的108~115字节。这样数据库在每次启动的时候只需要检查这两处的字节是否相同就可以判断上一次是否正常关闭了

InitRaw是创建一个新的页，并调用setVcOpen在100~107个字节上填充一组随机数

setVcOpen有两个重载，如果传入的是字节数组，那么就填充随机数，如果传入的是一个页，那就将其设置为脏页并调用入参为字节数组的setVcOpen来填充随机数，所以实际上这就是一个包装

setVcClose依然有两个重载，入参为字节数组是原型，进行随机字节的拷贝，入参为Page的是包装

checkVc逻辑依然相同

普通页以一个2字节无符号数起始，表示这一页的空闲位置的偏移(即起始), 剩下的部分就都是实际存储的数据. FSO是Free Space Offset

InitRaw是创建一个新的普通页, 调用SetFOS函数, 将入参ofData(新的偏移量)给写入页的头两个字节

getFSO有两个重载, 就是获取页的头两个字节, 并把其包装起来

insert是将要新增的数据给插入到指定的Page中, 并设置脏页, 插入数据的时候还需要调用getFSO方法获取到空余位置的偏移量, 数据插入结束后需要重新设定FSO

getFreeSpace就是一个简单的基于固定的PAGE_SIZE和页的FSO来计算剩余的空闲空间

两个recover函数就是在数据库崩溃后重新打开时恢复之前没有完成的插入数据和更新数据, 首先将page设置为脏页, 然后将需要恢复的数据从offset(这个offset从哪里来的先别管)处写入, 然后获取这页的FSO, 如果小于新写入后的偏移量, 那么就改为新的偏移量, 就是确保FSO所指向的位置开始一定是空闲的. 恢复更新数据的操作不需要重新设定FSO, 因为更新的数据长度一定是相等的