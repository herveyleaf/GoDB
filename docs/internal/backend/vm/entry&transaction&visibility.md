对于数据库的冲突, 暂时不考虑插入操作的前提下, 只看更新操作(U)和读操作(R), 对于同一个数据操作的冲突有两种: 两个不同事务的U操作冲突, 和, 两个不同事物的U, R操作冲突. 交换两个不冲突的操作的顺序不会对结果造成影响, 而交换两个冲突操作的顺序会对结果造成影响

GoDB实现了两段锁协议来实现调度序列的可串行化, 但是这种方法就不可避免的导致了事务间的互相阻塞, 甚至是死锁, 降低了事务处理的效率. 为此, GoDB实现了MVCC来提高效率, 降低死锁概率

MVCC即多版本并发控制, 在数据库中的某一个数据, 可以存在多个不同的版本(并非整个数据库有不同的版本), 某个事务对其进行操作的时候, 需要查看这条记录的隐藏的事务版本id, 比对事务id和事务隔离级别去判断读取哪一个版本的数据

DM层向上层提供了DataItem的概念, VM通过管理所有的数据项, 向上层提供了记录(Entry)这个概念, 上层模块通过VM操作数据的最小单位就是entry. VM在其内部为每个entry维护了多个版本, 每当上层模块对某个entry进行修改时, VM就会为这个entry创建一个新的版本

虽然理论上MVCC实现了多版本, 但是VM并没有提供update操作, 对于字段的更新操作由后面的TBM实现, 所以在VM的实现中, 一条记录只有一个版本

一条entry的结构如下: [XMIN][XMAX][DATA]. XMIN是创建该条记录(版本)的事务编号, 而XMAX是删除该条记录的事务编号. DATA就是这条记录持有的数据

如果一个记录的最新版本被加锁, 当另一个事务想要修改或读取这条数据的时候, GoDB会返回一个较旧版本的数据, 这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的

版本的可见性与事务的隔离度是相关的. GoDB支持的最低的事务隔离程度, 是读提交, 即事务在读取数据时, 只能读取已经提交事务产生的数据. GoDB实现读提交, 为每个版本维护了XMIN和XMAX两个变量. XMAX也解释了为什么DM不需要提供删除操作, 需要删除一个版本的时候, 只需要设置XMAX, 这样, 这个版本对每一个XMAX以后的事务都是不可见的, 也就等价于删除了

读提交会导致不可重复读和幻读的问题, GoDB实现了可重复读这个事务隔离程度来解决不可重复读这个问题